// 계산하리

#include <stdio.h>
int main() {
    int a, b;
    a = 10; // a 변수에 10을 대입
    b = 3;
    printf("a + b는 : %d \n", a + b);
    printf("a - b는 : %d \n", a - b);
    printf("a * b는 : %d \n", a * b);
    printf("a / b는 : %d \n", a / b); // a / b의 나눈 값 출력
    printf("a %% b는 : %d \n", a % b); // a / b의 나머지 값 출력 (%%는 %를 표시하기 위한 방법)
}

// 나눗셈 시에 주의할 점
#include <stdio.h>
int main2() {
    int a, b;
    a = 10;
    b = 3;
    printf("a / b는 : %f \n", a / b); // 해서는 안될 것
    return 0;
    
    /*
     나눗값이 3.33333... 이라고 실수형 데이터가 아님
     (정수형 변수) (연산) (정수형 변수)는 언제나 정수로 유지됨
    */
}

// 산술 변환
#include <stdio.h>
int main3() {
    int a; // 정수형 변수
    double b; // 실수형 변수
    
    a = 10;
    b = 3;
    printf("a / b는 : %f \n", a / b); // 3.333333
    printf("b / a는 : %f \n", b / a); // 0.300000
    return 0;
    
    /*
     연산 결과가 나오는 이유는 컴파일러에서 산술 변환이라는 과정을 거치기 때문
     어떠한 자료형이 다른 두 변수를 연산 할 때, 숫자의 범위가 큰 자료형으로 자료형들이 바뀜
     dobule이 int에 비해 포함하는 숫자가 더 크므로 a의 타입이 int -> double로 산술 변환
     + 정수형 변수와 실수형 변수가 만나면 무조건 실수형 변수쪽으로 상승되기에 %d로 받아올 수 없음 (double 형태로 나오기에)
    */
}

// 대입 연산자
#include <stdio.h>
int main4() {
    int a = 3; // 변수 선언과 동시에 집어넣을 수 있음
    a = a + 3; // a에다가 a + 3을 대입
    printf("a의 값은 : %d \n", a); // 6
    return 0;
    
    /*
     C언어에서는 = 보다 +를 먼저 연산함
    */
}

// 대입 연산자 - 1을 더하는 방법
#include <stdio.h>
int main5() {
    int a = 1, b = 1, c = 1, d = 1;
    
    a = a + 1; // a에 a에 1을 더한 값을 대입
    printf("a : %d \n", a);
    b += 1; // 복합 대입 연산
    printf("b : %d \n", b);
    /*
     b += x; / b = b + x;
     b -= x; / b = b - x;
     b *= x; / b = b * x;
     b /= x; / b = b / x;
     */
    ++c; // 증감 연산자 (전위형)
    printf("c : %d \n", c);
    d++; // 증감 연산자 (후위형)
    printf("d : %d \n", d);
    /*
     전위형은 1을 더해준 후 결과를 돌려줌
     후위형은 결과를 돌려준 후 1을 더해줌
    */
    
    return 0;
}

// 증감 연산자 (prefix, postfix)
#include <stdio.h>
int main6() {
    int a = 1;
    
    printf("++a : %d \n", ++a); // 2
    
    a = 1;
    printf("a++ : %d \n", a++); // 1
    printf("a : %d \n", a); // 2
    
    return 0;
    
    /*
     ++a는 전위형이기 때문에 a에 먼저 1을 더한 값인 2가 출력
     a++은 후위형이기 때문에 a의 값을 출력하였을 때 a에 1이 더해짐
     
     + 대입연산자 중에는 @++이 가장 빨리 연산됨
    */
}


// 비트 연산자

/*
 비트 연산자란 비트 하나 하나에 대해 연산을 함
 보통 8 비트(8 bit)를 묶어서 1 바이트(bite)라고 하고, 이진법으로 8자리 수라 볼 수 있음
 따라서 1 바이트로 나타낼 수 있는 수의 범위가 0부터 11111111로 십진수로 바꾸면 0부터 255까지 나타낼 수 있음
 
 비트 연산자 종류
 & (And 연산)
 | (Or 연산)
 ^ (XOR 연산)
 >>, << (쉬프트 연산)
 ~ (반전)
 
 1. And 연산 (&)
 1 1 = 1
 1 0 = 0
 0 1 = 0
 0 0 = 0
 둘 다 1일때 1, 아니면 0
 
 ex:
  1010
 &0011

 =0010
 
 2. Or 연산 (|)
 1 1 = 1
 1 0 = 1
 0 1 = 1
 0 0 = 0
 어느 하나만 1이여도 1, 아니면 0
 
 ex:
  1010
 |0011
 
 =1011
 
 3. XOR 연산 (^)
 1 1 = 0
 1 0 = 1
 0 1 = 1
 0 0 = 0
 두 수가 달라야지만 1, 아니면 0
 
 ex:
  1010
 ^0011
 
 =1001
 
 4. 반전 연산 (~)
 0을 1로 1을 0으로
 
 ex:
 ~1010

 =0101
 
 5-1. 쉬프트 연산 (<<)
 비트를 왼쪽으로 쉬프트(Shift) 시킴
 
 ex:
 101011 << 1
  101011
 1010110
 =010110
 
 + << 쉬프트 시, 앞에 쉬프트된 숫자가 갈 자리가 없다면 그 부분은 버려짐
   또한 새로 채워진 부분은 앞에서 버려진 숫자가 아닌 0이 붙음
 
 5-2. 쉬프트 연산 (>>)
 비트를 오른쪽으로 쉬프트(Shift) 시킴
 
 ex:
 11100010 >> 3
 =11111100

 + << 연산자와 다르게 앞부분 맨 왼쪽에 있던 수가 채워지게 됨 (1이면 1, 0이면 0)
*/

#include <stdio.h>

int main7() {
    int a = 0xAF; // 10101111
    int b = 0xB5; // 10110101
    
    printf("%x \n", a & b);  // 10100101 = a5
    printf("%x \n", a | b);  // 10111111 = bf
    printf("%x \n", a ^ b);  // 00011010 = 1a
    printf("%x \n", ~a);     // 1...101010000 = ffffff50
    /*
     ~a가 1...101010000인 이유:
     int는 4 바이트 = 32 비트, 하나의 비트가 0과 1을 나타낸다고 했으므로
     예로 a = 1이라고 하였을 때 00000000 0000... 0001이라 저장됨
     그래서 10101111이였던 a가 00000000 0000... 10101111이기 때문에
     ~a를 하게 된다면 11111111 1111... 10101111이 됨
     
     + 쉬프트 연산자도 똑같음
    */
    printf("%x \n", a >> 2); // 1010111100 = 2bc
    printf("%x \n", a << 3); // 00010110 = 16
    
    return 0;
}

/*
 연산 / 우선 / 순위
 1   ()  []  ->  (expr)++  (expr)--            왼쪽 우선
 2   !  ~  ++(부호)  --  *  &  sizeof  캐스트   오른쪽 우선
 3   *  /  %                                왼쪽 우선
 4   +  -   (덧셈, 뺄셈)                     왼쪽 우선
 5   <<  >>                                왼쪽 우선
 6   <  <=  >  >=                          왼쪽 우선
 7   ==  !=                                왼쪽 우선
 8   &                                     왼쪽 우선
 9   ^                                     왼쪽 우선
 10  |                                     왼쪽 우선
 11  &&                                    왼쪽 우선
 12  ||                                    왼쪽 우선
 13  ? :                                   오른쪽 우선
 14  =  복합대입                           오른쪽 우선
 15  ,                                     왼쪽 우선

 우선 순위는 a = b + c + d + e; 일 때
 1. b + c를 계산하고 그 결과를 반환 (결과를 C로 가정)
 2. C + d를 계산하고 그 결과를 반환 (결과를 D로 가정)
 3. D + e를 계산하고 그 결과를 반환 (결과를 E로 가정)
 
 따라서 위 식은 a = E가 됨
 
 만약 a = b = c = d = 3; 일 때
 1. d = 3
 2. c = d
 3. b = c
 4. a = b
 5. a, b, c, d = 3
 
 우선순위를 잘 파악하지 못하겠다면 괄호()를 이용하여 확실하게 하는 것이 좋음
*/
